---
title: "ARIMAX - Inflation Rate ~ Oil Price"
format:
  html:
    embed-resources: true
---
```{css, echo = FALSE}
.justify {
    text-align: justify !important;
    text-indent: 20px; 
}

.epigrafe {
    text-align: justify !important;
    text-indent: 20px; 
    border: 1.5px solid #87c8b5; 
    padding-top: 15px;
    padding-bottom: 5px;
    padding-right: 15px;
    padding-left: 15px;
    font-size: 14px;
    background-color: #f9f9f9; 
    margin: 20px 0px 30px 0px;
}
```

``` {r}
#| echo: false
#| message: false
#| code-fold: true
#| code-summary: "Libraries"
#| results: 'hide'
#| warning: false

library(tidyverse)
library(ggplot2)
library(forecast)
library(astsa)
library(xts)
library(tseries)
library(fpp2)
library(fma)
library(lubridate)
library(TSstudio)
library(quantmod)
library(tidyquant)
library(plotly)
library(gridExtra)
library(readxl)
library(imputeTS)
library(zoo)
library(knitr)
library(kableExtra)
library(patchwork)
```

### Dataset

::: {.epigrafe}
Our approach uses three different datasets. The primary macroeconomic variable, the inflation rate, is complemented by external factors, namely the oil price and oil production. To facilitate a holistic analysis, we have merged these datasets into one.
:::

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false

# Import dataset
df_inflation <- read_csv('../data/viz_inflation.csv')

# Rename columns
names(df_inflation) <- c('DATE', 'Value')

# Import dataset
df_oil_price_month <- read_csv('../data/df_oil_price_month.csv')

# Import dataset
df_oil_price_month <- read_csv('../data/df_oil_price_month.csv')

# Create Date
df_oil_price_month <- df_oil_price_month %>%
  mutate(date2 = make_date(year(date), month(date), 01))

# Import dataset
df_oil_production_us <- read_csv('../data/viz_us_oil_production.csv')

# Rename columns
names(df_oil_production_us) <- c('date', 'Value')

# Create Date
df_oil_production_us <- df_oil_production_us %>%
  mutate(date2 = make_date(year(date), month(date), 01))


# Check maximum starting date between datasets
if(min(df_inflation$DATE) >= min(df_oil_price_month$date))
{
    min_date <- min(df_inflation$DATE)
}else 
    {
        min_date <-min(df_oil_price_month$date)
    }

# Check maximum starting date between datasets
if(min_date >= min(df_oil_price_month$date))
{
    min_date <- min_date
}else 
    {
        min_date <-min(df_oil_production_us$date)
    }

# Keep relevant columns
df_oil_price_month <- df_oil_price_month %>% dplyr::select('date2', 'adjusted')

# Keep relevant columns
df_oil_production_us <- df_oil_production_us %>% dplyr::select('date2', 'Value')

# Rename columns
names(df_inflation) <- c('DATE', 'inflation')

# Rename columns
names(df_oil_price_month) <- c('DATE', 'oil_price')

# Rename columns
names(df_oil_production_us) <- c('DATE', 'oil_production')

# Filter starting date
df_inflation <- df_inflation %>% filter(DATE >= min_date)

# Filter starting date
df_oil_price_month <- df_oil_price_month %>% filter(DATE >= min_date)

# Filter starting date
df_oil_production_us <- df_oil_production_us %>% filter(DATE >= min_date)

# Combine datasets
dd <- merge(df_inflation, df_oil_price_month, by.x = "DATE", by.y = "DATE", all = TRUE)

# Combine datasets
dd <- merge(dd, df_oil_production_us, by.x = "DATE", by.y = "DATE", all = TRUE)

# Order by Date sort ascending
dd <- dd %>% arrange(DATE)

# Create the time series object
dd.ts <- ts(dd,start=min_date,frequency = 12)

# Show table
knitr::kable(head(dd))
```

### Plot

::: {.epigrafe}
The next important step is to visualize the original data. The graph below provides a separate axis for each variable considered, facilitating a comprehensive understanding of their individual patterns. The first insight we obtain is the difference in units. For this reason we need to transform the *oil production* variable.
:::

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false

# Plot time series for both variables.
autoplot(dd.ts[,c(2:4)], facets=TRUE) +
  xlab("Date") + ylab("") +
  ggtitle("Oil Price and Oil Production influencing Inflation Rate")
```

### Linear Model

::: {.epigrafe}
As we continue our time series analysis, a critical step is to test the transformation of the oil production variable. Upon examination, we notice a significant change in the significance level within the general linear model, rendering the variable insignificant. As a result, we decide to keep the variable in its original form. We also decide to use a general linear model, recognizing the absence of a presumed linearity among the variables analyzed.

To assess the performance of this model, we examine the autocorrelation function (ACF) and partial autocorrelation function (PACF) plots for the residuals time series. These plots prove to be informative, revealing pronounced autocorrelation over numerous lags.
:::

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false

# Create ts for Bus Passengers
dd$inflation <- ts(dd$inflation, start=min_date,frequency = 12)

# Create ts for Oil Price
dd$oil_price <- ts(dd$oil_price, start=min_date,frequency = 12)

# Create ts for Oil Price
dd$oil_production <- ts(dd$oil_production, start=min_date,frequency = 12)

# Fit the linear model
fit.reg <- glm(inflation ~ oil_price + oil_production, data=dd)

summary(fit.reg)
```

### Autocorrelation Plots

``` {r, fig.width = 8, fig.height = 6}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false


res.fit <- ts(residuals(fit.reg),star=decimal_date(min_date),frequency = 12)

# ACF Plot
acf_plot <- ggAcf(res.fit, main="ACF Plot for Residuals")

# PACF Plot
pacf_plot <- ggPacf(res.fit, main="PACF Plot for Residuals")

# Arrange Plots
grid.arrange(acf_plot, pacf_plot, nrow=2)
```


### Differencing

::: {.epigrafe}

The ACF plot provides a clear visual indication of high autocorrelation over most of the lags plotted. Recognizing the need for stationarity, the next critical step in our analysis is to perform differencing on the data. This process is performed to mitigate the observed autocorrelation patterns.
:::

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "First Ordinary Difference"
#| warning: false

# Ordinary Differencing
res.fit %>% diff() %>% ggtsdisplay()
```

### Model Parameters

::: {.epigrafe}

By analyzing the ACF and PACF plots, we identified the following parameters for testing different time series models:


$p = 2$

$d = 1$

$q = 2$

We also included the auto.arima function for comparison. However, it should be noted that auto.arima detected a seasonal component that was not visually apparent in either the time series plot or the ACF plot. Therefore, we decided not to use auto.arima in our analysis.
:::

::: {.panel-tabset}

## Parameters

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false

xt <- res.fit

# PACF plot parameter selection
p_value <- 3

# Number of differences
d_value <- 2

# ACF plot parameter selection
q_value <- 3

# Initialize variable
i <- 1

# Initialize variable
temp <- data.frame()

# Calculate number of rows
rows <- p_value*d_value*q_value

# 
ls <- matrix(rep(NA,6*rows),nrow=rows) 

# Parameter testing loop
for (p in 1:p_value+1)
{
  for(q in 1:q_value+1)
  {
    for(d in 1:d_value)
    {
      
      #if(p-1+d+q-1<=8) #usual threshold
      #{
        
        model<- Arima(xt,order=c(p-1,d-1,q-1),include.drift=TRUE) 
        ls[i,]= c(p-1,d-1,q-1,model$aic,model$bic,model$aicc)
        i=i+1
        #print(i)
        
      #}
      
    }
  }
}

temp <- as.data.frame(ls)

names(temp) <- c("p","d","q","AIC","BIC","AICc")

#temp
#knitr::kable(temp)
```

``` {r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false

# Check best model with AIC
temp[which.min(temp$AIC),]

# Check best model with BIC
temp[which.min(temp$BIC),]

# Check best model with AICc
temp[which.min(temp$AICc),]
```

## auto.arima()

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false

# Assign the exogenous variable
xreg <- dd.ts[,c(3:4)]

fit_auto_arima <- auto.arima(dd.ts[, "inflation"], xreg = xreg)

summary(fit_auto_arima)
```

:::

### Model Diagnostics

::: {.epigrafe}

The evaluation of the model selection criteria shows a consistent preference for the (3,0,3) model by AIC and AICc, while BIC was found to minimize the (1,1,1) model. 

A comprehensive evaluation of their performance included a careful analysis of diagnostic plots and auto.arima() results. Upon comparison, the (3,0,3) model emerges as a superior choice. The standardized residuals show an apparently random pattern, the Q-Q plot shows a trend toward normality, and some Ljung box statistics fall slightly below the significance level, indicating minimal autocorrelation.

:::

::: {.panel-tabset}

## AIC

``` {r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Model Diagnostics - parameters with best AIC"
#| warning: false

AIC <- temp[which.min(temp$AIC),]

p1 <- AIC$p
d1 <- AIC$d
q1 <- AIC$q

# Model diagnostics for best AIC
model_output <- capture.output(sarima(xt, p1, d1, q1))
```

## BIC

``` {r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Model Diagnostics - parameters with best BIC"
#| warning: false

BIC <- temp[which.min(temp$BIC),]

p2 <- BIC$p
d2 <- BIC$d
q2 <- BIC$q

# Model diagnostics for best BIC
model_output <- capture.output(sarima(xt, p2, d2, q2))
```

:::

### Fit Model

::: {.epigrafe}
We can observe that there should be an accurate predictive model by observing the fit model.
:::

::: {.panel-tabset}

## Model Fit Plot

``` {r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| code-summary: "Model Fitting"


best_model <- temp[which.min(temp$AIC),]

p <- best_model$p
d <- best_model$d
q <- best_model$q


model <- Arima(xt,order=c(p, d, q),include.drift = TRUE)

plot(xt, col="black")
lines(fitted(model), col="green")
legend(x = "topleft", legend = c("xt", "BIC"), col = c("black", "green"), lty = 1)
```

## Model Summary

``` {r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Fitted Model Summary"
#| warning: false

fit <- Arima(xt, order=c(p, d, q))
summary(fit)
```

:::

### Equation

::: {.epigrafe}

\begin{align}
x_t &= 0.9790 x_{t-1} - 0.8660 w_{t-1} + 0.2807 w_{t-2} + 0.2446 x_{t-12} - 0.9400 w_{t-12} + w_t
\end{align}

:::

### Forecast Plot

### Forecast

::: {.epigrafe}
The final version of the model is an ARIMA (3, 0, 3) model, which indicates that future inflation rates will tend to fall.
:::

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "{r}"
#| warning: false

forecast_fit <- forecast(fit,36)

# Path to save plot
file_path <- "../images/7_inflation.png"

# Plot
plot <- autoplot(forecast_fit)

# Use ggsave to save the plot as a PNG image
ggsave(plot, filename = file_path, width = 10, height = 5)

# Show plot
plot
```

### Benchmark Models

``` {r, fig.width = 8, fig.height = 4}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Benchmark Models Plot"
#| warning: false

autoplot(xt) +
  autolayer(meanf(xt, h=11),
            series="Mean", PI=FALSE) +
  autolayer(naive(xt, h=11),
            series="Naïve", PI=FALSE) +
  autolayer(snaive(xt, h=11),
            series="Seasonal naïve", PI=FALSE) +
  autolayer(forecast(forecast_fit, h=11),
            series="Fit", PI=FALSE) +
  ggtitle("Forecasts for Oil Price") +
  xlab("Year") + ylab("Price") +
  guides(colour=guide_legend(title="Forecast"))
```
